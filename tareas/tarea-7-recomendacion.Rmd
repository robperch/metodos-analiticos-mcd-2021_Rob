---
title: "Filtrado colaborativo (similitud) con datos de Netflix"
output: html_notebook
---


Para este ejercicio, necesitas bajar a la carpeta datos/netflix los [datos de Netflix](https://s3.amazonaws.com/ma-netflix/dat_muestra_nflix.csv)

Lee y prepara los datos con el siguiente código:

```{r leertabla1}
library(tidyverse)
# nombres de películas
pelis_nombres <- read_csv('../datos/netflix/movies_title_fix.csv', 
  col_names = FALSE, na = c("", "NA", "NULL"))
names(pelis_nombres) <- c('peli_id','año','nombre')
# leer ratings
dat_netflix <- read_csv( "../datos/netflix/dat_muestra_nflix.csv", 
      progress = FALSE) %>% 
    select(-usuario_id_orig) %>% 
    mutate(usuario_id = as.integer(as.factor(usuario_id))) #usuario único
```

Separa entrenamiento y validación:

```{r}
set.seed(28882)
# seleccionar usuarios y peliculas
usuarios <- dat_netflix %>% select(usuario_id) %>% distinct
valida_usuarios <- usuarios %>% sample_frac(0.2) 

peliculas <-  dat_netflix %>% select(peli_id) %>% distinct
valida_pelis <- peliculas %>% sample_frac(0.2)

# filtar validación
dat_valida <- dat_netflix %>% 
  semi_join(valida_usuarios) %>% semi_join(valida_pelis) 

# entrenamiento
dat_entrena <- dat_netflix %>% anti_join(dat_valida)
n_valida <- dat_valida %>% tally %>% pull(n)
n_entrena <- dat_entrena %>% tally %>% pull(n)
sprintf("Entrenamiento: %1d, Validación: %2d, Total: %3d", n_entrena, 
        n_valida, n_entrena + n_valida)
```


**Pregunta 1**: explica por qué escogimos un número de usuarios al azar,
un número de películas al azar, y construimos el conjunto de validación con
las calificaciones de esos usuarios y esas películas. ¿Qué pasa si simplemente
escogemos un conjunto de usuarios y ponemos todas sus calificaciones en validación?

- Debido a que se trata de datos sin temporalidad, debemos elegir un conjunto de datos al azar para desarrollar un modelo adecuado. 
- Si simplemente hubiéramos elegido un conjunto sin azar, pudiéramos obtener una muestra no representativa de los datos.
- En realidad sí hay un componente temporal que deberíamos cuidar. Entrenamiento debe ir con el histórico y validación hacia adelante.
  - Podemos escoger para validación las calificaciones más reciente de un usuario.
- También lo importante es asegurarnos de que en el conjunto de validación tengamos usuarios que no sean nuevos solamente.




## Similitud y filtrado colaborativo


Primero exploramos similitud coseno entre películas. Como explicamos,
centramos por usuario:

```{r}
dat_entrena_c <- dat_entrena %>%
  group_by(usuario_id) %>%
  mutate(calif_c = calif - mean(calif)) %>% 
  ungroup() %>% 
  select(peli_id, usuario_id, calif_c)
```

Similitud coseno:

```{r}
sim_cos <- function(x,y){
  # obsérvese que excluímos del cálculo NA's
  pp <- sum(x*y, na.rm = T)
  pnormas <- sqrt(sum(x^2, na.rm = T)) * sqrt(sum(y^2, na.rm = T))
  pp / pnormas
}
```

```{r}
ejemplos <- function(pelicula){
  
  mi_peli <- filter(dat_entrena_c, peli_id==pelicula) %>% 
             rename(peli_id_1 = peli_id, calif_c_1 = calif_c)
  
  # vamos a calcular todas las similitudes con mi_peli - esto no es buena
  # idea y discutiremos más adelante cómo evitarlo
  
  datos_comp <- left_join(dat_entrena_c, mi_peli)
  
  # calcular similitudes
  out_sum <- datos_comp %>% 
      group_by(peli_id) %>%
      summarise(dist = sim_cos(calif_c, calif_c_1), num_pares = n()) %>% 
      left_join(pelis_nombres)
  
  out_sum %>% arrange(desc(dist))  %>% select(nombre, dist, num_pares)
  
}
```

```{r}
pelis_nombres %>% 
  filter(peli_id==28)
# id 28 es Lilo and Stitch
ejemplos(28) %>% filter(num_pares > 500) %>% head(20)
```



**Pregunta 2**: Escoge 2 o 3 películas que te parezcan interesantes (que tengan al menos unas 1000 evaluaciones). Por ejemplo, alguna película popular de niños, alguna serie, etc. ¿Cuáles son las 10 películas más similares según el código de arriba?
- Nota: algo interesante es que el algoritmo no es espejo. Cuando buscas por "Lilo & Stitch", "Lilo & Stitch 2" sale con una similitud de 0.25 (aprox); cuando buscar "Lilo & Stitch 2", "Lilo & Stitch" sale con una similitud menor.
  - El problema con esta falta de "espejo" es que no se están procesando bien los "N/A's"
  - Para resolver esto podríamos poner un filtro para que se eliminen todos los "N/A's"
- También, una vez vista la película 

```{r}
## Selección 1

pelis_nombres %>% 
  filter(grepl("Fight Club", nombre))

peli_id_sel <- 5926

dat_netflix %>% 
  filter(peli_id==peli_id_sel) %>% 
  tally()

ejemplos(peli_id_sel) %>% filter(num_pares > 500) %>% head(11) %>% arrange(dist)
```



```{r}
## Selección 2

pelis_nombres %>% 
  filter(grepl("Gump", nombre))

peli_id_sel <- 11283

dat_netflix %>% 
  filter(peli_id==peli_id_sel) %>% 
  tally()

ejemplos(peli_id_sel) %>% filter(num_pares > 500) #%>% arrange(dist)
```



**Pregunta 3**: ¿qué es *num_pares* en la tabla que sale del código de arriba? ¿qué pasa si no filtramos con num_pares > 300 (experimenta haciendo este número más chico o más grande).
- Se refiere al número de comparaciones que estamos haciendo entre dos ratings emitidos por un usuario para la película seleccionada y otra vista por el mismo.
- Disminuyendo el número de pares aumentamos el número de resultados. Hacemos más laxa la métrica para hacer recomendaciones. Dejamos pasar más basura.



**Pregunta 4**: ¿cómo podrías usar este método para hacer recomendaciones a un usuario? Piensa en al menos dos maneras.
1. Una sería pidiéndole al usuario que especifique una película similar a la que le gustaría que le recomienden. El algoritmo emitiría una lista de los resultados.
2. Utilizar la lista de "amigos" del usuario para emitir recomendaciones ponderadas con base en dicha lista.



## Mediciones en escala

Revisa las notas que vimos en clase para contestar:

**Pregunta 5**: ¿Qué problemas típicos encontramos al calcular  correlaciones de dos variables medidas en escala (por ejemplo, gusto por dos películas en netflix)? ¿Crees que estos problemas se solucionan binarizando las escalas (por ejemplo 5 es 1 y 1,2,3,4 es 0)?
- Tenemos el problema de que los usuarios pueden interpretar y utilizar la escala de distinta manera (heterogeneidad en uso de escala).
- Binarizar puede ayudar, sin embargo, creo que sería mejor sustituir la escala por un una opción binaria o tomar medidas indirectas para estimar medidas de satisfacción.
